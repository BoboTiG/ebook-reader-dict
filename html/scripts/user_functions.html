<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>scripts.user_functions API documentation</title>
<meta name="description" content="Functions that can be used in *templates_multi* of any locale …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scripts.user_functions</code></h1>
</header>
<section id="section-intro">
<p>Functions that can be used in <em>templates_multi</em> of any locale.</p>
<p>Check the "html/scripts/user_functions.html" file for a user-friendly version.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Functions that can be used in *templates_multi* of any locale.

Check the &#34;html/scripts/user_functions.html&#34; file for a user-friendly version.
&#34;&#34;&#34;
import re
from typing import List, Optional, Tuple
from warnings import warn

from .lang import all_langs, templates_italic


def capitalize(text: str) -&gt; str:
    &#34;&#34;&#34;
    Capitalize the first letter only.

        &gt;&gt;&gt; capitalize(&#34;&#34;)
        &#39;&#39;
        &gt;&gt;&gt; capitalize(&#34;alice&#34;)
        &#39;Alice&#39;
        &gt;&gt;&gt; capitalize(&#34;BOB&#34;)
        &#39;BOB&#39;
        &gt;&gt;&gt; capitalize(&#34;alice and bob&#34;)
        &#39;Alice and bob&#39;
    &#34;&#34;&#34;
    if not text:
        return &#34;&#34;
    return f&#34;{text[0].capitalize()}{text[1:]}&#34;


def century(parts: Tuple[str, ...], century: str) -&gt; str:
    &#34;&#34;&#34;
    Format centuries.

        &gt;&gt;&gt; century([&#34;siècle&#34;, &#34;XVI&#34;], &#34;siècle&#34;)
        &#39;XVI&lt;sup&gt;e&lt;/sup&gt; siècle&#39;
        &gt;&gt;&gt; century([&#34;siècle&#34;, &#34;XVIII&#34;, &#34;XIX&#34;], &#34;century&#34;)
        &#39;XVIII&lt;sup&gt;e&lt;/sup&gt; century - XIX&lt;sup&gt;e&lt;/sup&gt; century&#39;
    &#34;&#34;&#34;
    return &#34; - &#34;.join(f&#34;{p}{superscript(&#39;e&#39;)} {century}&#34; for p in parts[1:])


def chimy(composition: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Format chimy notations.

        &gt;&gt;&gt; chimy([&#34;H&#34;, &#34;2&#34;, &#34;O&#34;])
        &#39;H&lt;sub&gt;2&lt;/sub&gt;O&#39;
        &gt;&gt;&gt; chimy([&#34;FeCO&#34;, &#34;3&#34;, &#34;&#34;])
        &#39;FeCO&lt;sub&gt;3&lt;/sub&gt;&#39;
    &#34;&#34;&#34;
    return &#34;&#34;.join(subscript(c) if c.isdigit() else c for c in composition)


def color(rgb: str) -&gt; str:
    &#34;&#34;&#34;
    Format a RGB hexadecimal color.

        &gt;&gt;&gt; color(&#34;#B0F2B6&#34;)
        &#39;[RGB #B0F2B6]&#39;
    &#34;&#34;&#34;
    return f&#34;[RGB {rgb}]&#34;


def concat(
    parts: Tuple[str, ...],
    sep: str = &#34;&#34;,
    indexes: Optional[List[int]] = None,
    skip: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Simply concat all *parts* using the *sep* character as glue.

    If *indexes* is set, it must be a list of integers where each of one is the part number to keep.
    If *skip* is set, it must be a string. If a part is equal to *skip* then is it skipped and the
    *sep* become a single space.
    It allowes to filter out some parts while keeping others.

        &gt;&gt;&gt; concat([&#34;92&#34;, &#34;%&#34;])
        &#39;92%&#39;
        &gt;&gt;&gt; concat([&#34;O&#34;, &#34;M&#34;, &#34;G&#34;], sep=&#34;!&#34;)
        &#39;O!M!G&#39;
        &gt;&gt;&gt; concat([&#34;sport&#34;], sep=&#34; &#34;, indexes=[0, 2])
        &#39;sport&#39;
        &gt;&gt;&gt; concat([&#34;sport&#34;, &#34;fr&#34;, &#34;collectif&#34;], sep=&#34; &#34;, indexes=[0, 2])
        &#39;sport collectif&#39;
        &gt;&gt;&gt; concat([&#34;marca&#34;, &#34;ca&#34;, &#34;antigament&#34;, &#34;_&#34;, &#34;en plural&#34;], sep=&#34; &#34;, indexes=[2, 3, 4, 5], skip=&#34;_&#34;)
        &#39;antigament en plural&#39;
        &gt;&gt;&gt; concat([&#34;antigament&#34;, &#34;_&#34;, &#34;en plural&#34;], sep=&#34;,&#34;, skip=&#34;_&#34;)
        &#39;antigament en plural&#39;
        &gt;&gt;&gt; concat([&#34;Arte&#34;, &#34;&#34;, &#34;&#34;], sep=&#34; e &#34;)
        &#39;Arte&#39;
    &#34;&#34;&#34;
    if indexes:
        result = [part for index, part in enumerate(parts) if index in indexes]
    else:
        result = list(parts)

    if skip:
        result = [part for part in result if part != skip]
        if parts.count(skip):
            sep = &#34; &#34;

    return sep.join(p for p in result if p)


def coord(values: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Format lon/lat coordinates.

        &gt;&gt;&gt; coord([&#34;04&#34;, &#34;39&#34;, &#34;N&#34;, &#34;74&#34;, &#34;03&#34;, &#34;O&#34;, &#34;type:country&#34;])
        &#39;04°39′N 74°03′O&#39;
    &#34;&#34;&#34;
    return &#34;{0}°{1}′{2} {3}°{4}′{5}&#34;.format(*values)


def etymology(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Display cross-language etymology.

        &gt;&gt;&gt; etymology(&#34;étyl|grc|fr&#34;.split(&#34;|&#34;))
        &#39;grec ancien&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|no|fr|mot=ski&#34;.split(&#34;|&#34;))
        &#39;norvégien &lt;i&gt;ski&lt;/i&gt;&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|la|fr|mot=invito|type=verb&#34;.split(&#34;|&#34;))
        &#39;latin &lt;i&gt;invito&lt;/i&gt;&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|grc|fr|mot=λόγος|tr=lógos|type=nom|sens=étude&#34;.split(&#34;|&#34;))
        &#39;grec ancien λόγος, &lt;i&gt;lógos&lt;/i&gt; (« étude »)&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|grc|fr|λόγος|lógos|étude|type=nom|lien=1&#34;.split(&#34;|&#34;))
        &#39;grec ancien λόγος, &lt;i&gt;lógos&lt;/i&gt; (« étude »)&#39;
        &gt;&gt;&gt; etymology(&#34;calque|la|fr&#34;.split(&#34;|&#34;))
        &#39;latin&#39;
        &gt;&gt;&gt; etymology(&#34;calque|en|fr|mot=to date|sens=à ce jour&#34;.split(&#34;|&#34;))
        &#39;anglais &lt;i&gt;to date&lt;/i&gt; (« à ce jour »)&#39;
        &gt;&gt;&gt; etymology(&#34;calque|sa|fr|mot=वज्रयान|tr=vajrayāna|sens=véhicule du diamant&#34;.split(&#34;|&#34;))
        &#39;sanskrit वज्रयान, &lt;i&gt;vajrayāna&lt;/i&gt; (« véhicule du diamant »)&#39;

    Source: https://fr.wiktionary.org/wiki/Mod%C3%A8le:%C3%A9tyl

    Source: https://fr.wiktionary.org/wiki/Mod%C3%A8le:calque
    &#34;&#34;&#34;
    l10n_src = parts[1]
    l10n_dst = parts[2]
    res = all_langs[l10n_dst][l10n_src]
    if len(parts) == 3:
        return res

    data = {}
    for part in parts[3:]:
        if &#34;=&#34; in part:
            key, value = part.split(&#34;=&#34;)
            data[key] = value
        elif &#34;mot&#34; not in data:
            data[&#34;mot&#34;] = part
        elif &#34;tr&#34; not in data:
            data[&#34;tr&#34;] = part
        elif &#34;sens&#34; not in data:
            data[&#34;sens&#34;] = part

    if &#34;tr&#34; in data:
        res += f&#34; {data[&#39;mot&#39;]}, &lt;i&gt;{data[&#39;tr&#39;]}&lt;/i&gt;&#34;
    else:
        res += f&#34; &lt;i&gt;{data[&#39;mot&#39;]}&lt;/i&gt;&#34;
    if &#34;sens&#34; in data:
        res += f&#34; (« {data[&#39;sens&#39;]} »)&#34;

    return res


def eval_expr(expr: str) -&gt; str:
    &#34;&#34;&#34;
    Compute and return the result of *expr*.

        &gt;&gt;&gt; eval_expr(&#34;2 ^ 30&#34;)
        &#39;1073741824&#39;

    *expr* is sanitized and only a small range of characters are allowed:

        &gt;&gt;&gt; eval_expr(&#34;cat /etc/passwd&#34;)  # doctest: +ELLIPSIS
        Traceback (most recent call last):
          File &#34;.../doctest.py&#34;, line 1329, in __run
            compileflags, 1), test.globs)
          File &#34;&lt;doctest scripts.user_functions.eval_expr[0]&gt;&#34;, line 1, in &lt;module&gt;
          File &#34;.../user_functions.py&#34;, line 33, in eval_expr
            raise ValueError(f&#34;Dangerous characters in the expr {expr!r}&#34;)
        ValueError: Dangerous characters in the expr &#39;cat /etc/passwd&#39;

    Allowed characters are digits (0-9), spaces and operators (+-*^).
    &#34;&#34;&#34;
    # Prevent horrors
    # digits, space and operators (+-*^)
    if re.search(r&#34;[^\d\s\*\-\+\^\.]+&#34;, expr):
        raise ValueError(f&#34;Dangerous characters in the expr {expr!r}&#34;)

    # Replace signs
    expr = expr.replace(&#34;^&#34;, &#34;**&#34;)

    return f&#34;{eval(expr)}&#34;


def int_to_roman(number: int) -&gt; str:
    &#34;&#34;&#34;
    Convert an integer to a Roman numeral.

        &gt;&gt;&gt; int_to_roman(12)
        &#39;XII&#39;
        &gt;&gt;&gt; int_to_roman(2020)
        &#39;MMXX&#39;

    Source: https://www.oreilly.com/library/view/python-cookbook/0596001673/ch03s24.html
    &#34;&#34;&#34;
    # if not 0 &lt; number &lt; 4000:
    #     raise ValueError(&#34;Argument must be between 1 and 3999&#34;)
    ints = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
    nums = (&#34;M&#34;, &#34;CM&#34;, &#34;D&#34;, &#34;CD&#34;, &#34;C&#34;, &#34;XC&#34;, &#34;L&#34;, &#34;XL&#34;, &#34;X&#34;, &#34;IX&#34;, &#34;V&#34;, &#34;IV&#34;, &#34;I&#34;)
    result = []
    for i in range(len(ints)):
        count = int(number / ints[i])
        result.append(nums[i] * count)
        number -= ints[i] * count
    return &#34;&#34;.join(result)


def italic(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by italic HTML tags.

        &gt;&gt;&gt; italic(&#34;foo&#34;)
        &#39;&lt;i&gt;foo&lt;/i&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;i&gt;{text}&lt;/i&gt;&#34;


def lookup_italic(word: str, locale: str) -&gt; str:
    &#34;&#34;&#34;
    Find the *word* from the *templates_italic* table of the given *locale*.

    If the *word* is not found, it is returned as-is.

        &gt;&gt;&gt; lookup_italic(&#34;&#34;, &#34;fr&#34;)
        &#39;&#39;
        &gt;&gt;&gt; lookup_italic(&#34;absol&#34;, &#34;fr&#34;)
        &#39;Absolument&#39;
        &gt;&gt;&gt; lookup_italic(&#34;inexistant&#34;, &#34;fr&#34;)
        &#39;inexistant&#39;
    &#34;&#34;&#34;
    return templates_italic[locale].get(word, word)


def number(number: str, fsep: str, tsep: str) -&gt; str:
    &#34;&#34;&#34;
    Format a number using the provided float and thousands separators.

        &gt;&gt;&gt; number(&#34;1 000 000 000 000&#34;, &#34;,&#34;, &#34; &#34;)
        &#39;1 000 000 000 000&#39;
        &gt;&gt;&gt; number(&#34;1000000&#34;, &#34;,&#34;, &#34; &#34;)
        &#39;1 000 000&#39;
        &gt;&gt;&gt; number(&#34;1000000&#34;, &#34;.&#34;, &#34;&#34;)
        &#39;1000000&#39;
        &gt;&gt;&gt; number(&#34;1000000&#34;, &#34;.&#34;, &#34;,&#34;)
        &#39;1,000,000&#39;
        &gt;&gt;&gt; number(&#34;-1000000&#34;, &#34;,&#34;, &#34; &#34;)
        &#39;-1 000 000&#39;
        &gt;&gt;&gt; number(&#34;-1000000&#34;, &#34;&#34;, &#34;&#34;)
        &#39;-1000000&#39;
        &gt;&gt;&gt; number(&#34;-1000000&#34;, &#34;.&#34;, &#34;,&#34;)
        &#39;-1,000,000&#39;
        &gt;&gt;&gt; number(&#34;4.54609&#34;, &#34;,&#34; , &#34; &#34;)
        &#39;4,54609&#39;
        &gt;&gt;&gt; number(&#34;4.54609&#34;, &#34;.&#34; , &#34;,&#34;)
        &#39;4.54609&#39;
        &gt;&gt;&gt; number(&#34;22905&#34;, &#34;,&#34; , &#34;.&#34;)
        &#39;22.905&#39;
    &#34;&#34;&#34;
    # Remove superfluous spaces
    number = number.replace(&#34; &#34;, &#34;&#34;)

    try:
        # Integer
        res = f&#34;{int(number):,}&#34;
    except ValueError:
        # Float
        res = f&#34;{float(number):,}&#34;

    # Replace the current thousands separator with &#34;|&#34;;
    # then replace the dot with the float separator;
    # and lastly replace the &#34;|&#34; with the deisred thousands separator.
    # This 3-steps-replacement is needed for when separators are replacing each other.
    return res.replace(&#34;,&#34;, &#34;|&#34;).replace(&#34;.&#34;, fsep).replace(&#34;|&#34;, tsep)


def person(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Format a person name.

        &gt;&gt;&gt; person([&#34;Aldous&#34;, &#34;Huxley&#34;])
        &#34;Aldous &lt;span style=&#39;font-variant:small-caps&#39;&gt;Huxley&lt;/span&gt;&#34;
        &gt;&gt;&gt; person([&#34;Théodore Agrippa d’&#34;, &#34;Aubigné&#34;])
        &#34;Théodore Agrippa d’ &lt;span style=&#39;font-variant:small-caps&#39;&gt;Aubigné&lt;/span&gt;&#34;
        &gt;&gt;&gt; person([&#34;Théodore Agrippa d’&#34;, &#34;Aubigné&#34;, &#34;&#39;=oui&#34;])
        &#34;Théodore Agrippa d’&lt;span style=&#39;font-variant:small-caps&#39;&gt;Aubigné&lt;/span&gt;&#34;
        &gt;&gt;&gt; person([&#34;L. L. Zamenhof&#34;])
        &#39;L. L. Zamenhof&#39;

    Source: https://fr.wiktionary.org/wiki/Mod%C3%A8le:nom_w_pc
    &#34;&#34;&#34;
    res = parts[0]
    if len(parts) &gt; 1:
        if parts[-1] != &#34;&#39;=oui&#34;:
            res += &#34; &#34;
        res += small_caps(parts[1])
    else:
        warn(f&#34;Malformed template in the Wikicode (parts={parts})&#34;)
    return res


def sentence(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Capitalize the first item in *parts* and concat with the second one.

        &gt;&gt;&gt; sentence(&#34;superlatif de|petit|fr&#34;.split(&#34;|&#34;))
        &#39;Superlatif de petit&#39;
        &gt;&gt;&gt; sentence(&#34;variante de|ranche|fr&#34;.split(&#34;|&#34;))
        &#39;Variante de ranche&#39;
        &gt;&gt;&gt; sentence(&#34;RFC|5322&#34;.split(&#34;|&#34;))
        &#39;RFC 5322&#39;
        &gt;&gt;&gt; sentence(&#34;comparatif de|bien|fr|adv&#34;.split(&#34;|&#34;))
        &#39;Comparatif de bien&#39;
    &#34;&#34;&#34;
    return capitalize(concat(parts, sep=&#34; &#34;, indexes=[0, 1]))


def small(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by small HTML tags.

        &gt;&gt;&gt; small(&#34;foo&#34;)
        &#39;&lt;small&gt;foo&lt;/small&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;small&gt;{text}&lt;/small&gt;&#34;


def small_caps(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by the CSS style to use small capitals.

    Small-caps glyphs typically use the form of uppercase letters but are reduced
    to the size of lowercase letters.

        &gt;&gt;&gt; small_caps(&#34;Dupont&#34;)
        &#34;&lt;span style=&#39;font-variant:small-caps&#39;&gt;Dupont&lt;/span&gt;&#34;
    &#34;&#34;&#34;
    return f&#34;&lt;span style=&#39;font-variant:small-caps&#39;&gt;{text}&lt;/span&gt;&#34;


def strong(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by strong HTML tags.

        &gt;&gt;&gt; strong(&#34;foo&#34;)
        &#39;&lt;b&gt;foo&lt;/b&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;b&gt;{text}&lt;/b&gt;&#34;


def subscript(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by subscript HTML tags.

    Subscript text appears half a character below the normal line,
    and is sometimes rendered in a smaller font.
    Subscript text can be used for chemical formulas.

        &gt;&gt;&gt; subscript(&#34;foo&#34;)
        &#39;&lt;sub&gt;foo&lt;/sub&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;sub&gt;{text}&lt;/sub&gt;&#34;


def superscript(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by superscript HTML tags.

    Superscript text appears half a character above the normal line,
    and is sometimes rendered in a smaller font.

        &gt;&gt;&gt; superscript(&#34;foo&#34;)
        &#39;&lt;sup&gt;foo&lt;/sup&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;sup&gt;{text}&lt;/sup&gt;&#34;


def tag(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Get only interesting values from *parts*.

    - values without `=`
    - values starting with `text=`

    Source: https://sv.wiktionary.org/wiki/Mall:tagg

        &gt;&gt;&gt; tag([&#34;historia&#34;])
        &#39;historia&#39;
        &gt;&gt;&gt; tag([&#34;biologi&#34;, &#34;allmänt&#34;])
        &#39;biologi, allmänt&#39;
        &gt;&gt;&gt; tag(&#34;politik|formellt|språk=tyska&#34;.split(&#34;|&#34;))
        &#39;politik, formellt&#39;
        &gt;&gt;&gt; tag(&#34;kat=nedsättande|text=något nedsättande&#34;.split(&#34;|&#34;))
        &#39;något nedsättande&#39;
    &#34;&#34;&#34;
    words = []

    for part in parts:
        if &#34;=&#34; not in part:
            words.append(part)
        elif part.startswith(&#34;text=&#34;):
            words.append(part.split(&#34;=&#34;)[1])

    return &#34;, &#34;.join(words)


def term(text: str) -&gt; str:
    &#34;&#34;&#34;
    Format a &#34;term&#34;, e.g. return the *text* in italic and surrounded by parenthesis.

    If the *text* is already in such style, it will not be processed again.

        &gt;&gt;&gt; term(&#34;&#34;)
        &#39;&#39;
        &gt;&gt;&gt; term(&#34;foo&#34;)
        &#39;&lt;i&gt;(foo)&lt;/i&gt;&#39;
        &gt;&gt;&gt; term(&#34;Foo&#34;)
        &#39;&lt;i&gt;(Foo)&lt;/i&gt;&#39;
        &gt;&gt;&gt; term(&#34;&lt;i&gt;(Foo)&lt;/i&gt;&#34;)
        &#39;&lt;i&gt;(Foo)&lt;/i&gt;&#39;
    &#34;&#34;&#34;
    if not text:
        return &#34;&#34;
    elif text.startswith(&#34;&lt;i&gt;(&#34;):
        return text
    return italic(f&#34;({text})&#34;)


__all__ = (
    &#34;capitalize&#34;,
    &#34;century&#34;,
    &#34;chimy&#34;,
    &#34;color&#34;,
    &#34;concat&#34;,
    &#34;coord&#34;,
    &#34;etymology&#34;,
    &#34;eval_expr&#34;,
    &#34;int_to_roman&#34;,
    &#34;italic&#34;,
    &#34;lookup_italic&#34;,
    &#34;number&#34;,
    &#34;person&#34;,
    &#34;sentence&#34;,
    &#34;small&#34;,
    &#34;small_caps&#34;,
    &#34;strong&#34;,
    &#34;subscript&#34;,
    &#34;superscript&#34;,
    &#34;tag&#34;,
    &#34;term&#34;,
)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="scripts.user_functions.capitalize"><code class="name flex">
<span>def <span class="ident">capitalize</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Capitalize the first letter only.</p>
<pre><code>&gt;&gt;&gt; capitalize("")
''
&gt;&gt;&gt; capitalize("alice")
'Alice'
&gt;&gt;&gt; capitalize("BOB")
'BOB'
&gt;&gt;&gt; capitalize("alice and bob")
'Alice and bob'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def capitalize(text: str) -&gt; str:
    &#34;&#34;&#34;
    Capitalize the first letter only.

        &gt;&gt;&gt; capitalize(&#34;&#34;)
        &#39;&#39;
        &gt;&gt;&gt; capitalize(&#34;alice&#34;)
        &#39;Alice&#39;
        &gt;&gt;&gt; capitalize(&#34;BOB&#34;)
        &#39;BOB&#39;
        &gt;&gt;&gt; capitalize(&#34;alice and bob&#34;)
        &#39;Alice and bob&#39;
    &#34;&#34;&#34;
    if not text:
        return &#34;&#34;
    return f&#34;{text[0].capitalize()}{text[1:]}&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.century"><code class="name flex">
<span>def <span class="ident">century</span></span>(<span>parts: Tuple[str, ...], century: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format centuries.</p>
<pre><code>&gt;&gt;&gt; century(["siècle", "XVI"], "siècle")
'XVI&lt;sup&gt;e&lt;/sup&gt; siècle'
&gt;&gt;&gt; century(["siècle", "XVIII", "XIX"], "century")
'XVIII&lt;sup&gt;e&lt;/sup&gt; century - XIX&lt;sup&gt;e&lt;/sup&gt; century'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def century(parts: Tuple[str, ...], century: str) -&gt; str:
    &#34;&#34;&#34;
    Format centuries.

        &gt;&gt;&gt; century([&#34;siècle&#34;, &#34;XVI&#34;], &#34;siècle&#34;)
        &#39;XVI&lt;sup&gt;e&lt;/sup&gt; siècle&#39;
        &gt;&gt;&gt; century([&#34;siècle&#34;, &#34;XVIII&#34;, &#34;XIX&#34;], &#34;century&#34;)
        &#39;XVIII&lt;sup&gt;e&lt;/sup&gt; century - XIX&lt;sup&gt;e&lt;/sup&gt; century&#39;
    &#34;&#34;&#34;
    return &#34; - &#34;.join(f&#34;{p}{superscript(&#39;e&#39;)} {century}&#34; for p in parts[1:])</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.chimy"><code class="name flex">
<span>def <span class="ident">chimy</span></span>(<span>composition: Tuple[str, ...]) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format chimy notations.</p>
<pre><code>&gt;&gt;&gt; chimy(["H", "2", "O"])
'H&lt;sub&gt;2&lt;/sub&gt;O'
&gt;&gt;&gt; chimy(["FeCO", "3", ""])
'FeCO&lt;sub&gt;3&lt;/sub&gt;'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chimy(composition: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Format chimy notations.

        &gt;&gt;&gt; chimy([&#34;H&#34;, &#34;2&#34;, &#34;O&#34;])
        &#39;H&lt;sub&gt;2&lt;/sub&gt;O&#39;
        &gt;&gt;&gt; chimy([&#34;FeCO&#34;, &#34;3&#34;, &#34;&#34;])
        &#39;FeCO&lt;sub&gt;3&lt;/sub&gt;&#39;
    &#34;&#34;&#34;
    return &#34;&#34;.join(subscript(c) if c.isdigit() else c for c in composition)</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.color"><code class="name flex">
<span>def <span class="ident">color</span></span>(<span>rgb: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format a RGB hexadecimal color.</p>
<pre><code>&gt;&gt;&gt; color("#B0F2B6")
'[RGB #B0F2B6]'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def color(rgb: str) -&gt; str:
    &#34;&#34;&#34;
    Format a RGB hexadecimal color.

        &gt;&gt;&gt; color(&#34;#B0F2B6&#34;)
        &#39;[RGB #B0F2B6]&#39;
    &#34;&#34;&#34;
    return f&#34;[RGB {rgb}]&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.concat"><code class="name flex">
<span>def <span class="ident">concat</span></span>(<span>parts: Tuple[str, ...], sep: str = '', indexes: Union[List[int], NoneType] = None, skip: Union[str, NoneType] = None) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Simply concat all <em>parts</em> using the <em>sep</em> character as glue.</p>
<p>If <em>indexes</em> is set, it must be a list of integers where each of one is the part number to keep.
If <em>skip</em> is set, it must be a string. If a part is equal to <em>skip</em> then is it skipped and the
<em>sep</em> become a single space.
It allowes to filter out some parts while keeping others.</p>
<pre><code>&gt;&gt;&gt; concat(["92", "%"])
'92%'
&gt;&gt;&gt; concat(["O", "M", "G"], sep="!")
'O!M!G'
&gt;&gt;&gt; concat(["sport"], sep=" ", indexes=[0, 2])
'sport'
&gt;&gt;&gt; concat(["sport", "fr", "collectif"], sep=" ", indexes=[0, 2])
'sport collectif'
&gt;&gt;&gt; concat(["marca", "ca", "antigament", "_", "en plural"], sep=" ", indexes=[2, 3, 4, 5], skip="_")
'antigament en plural'
&gt;&gt;&gt; concat(["antigament", "_", "en plural"], sep=",", skip="_")
'antigament en plural'
&gt;&gt;&gt; concat(["Arte", "", ""], sep=" e ")
'Arte'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def concat(
    parts: Tuple[str, ...],
    sep: str = &#34;&#34;,
    indexes: Optional[List[int]] = None,
    skip: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Simply concat all *parts* using the *sep* character as glue.

    If *indexes* is set, it must be a list of integers where each of one is the part number to keep.
    If *skip* is set, it must be a string. If a part is equal to *skip* then is it skipped and the
    *sep* become a single space.
    It allowes to filter out some parts while keeping others.

        &gt;&gt;&gt; concat([&#34;92&#34;, &#34;%&#34;])
        &#39;92%&#39;
        &gt;&gt;&gt; concat([&#34;O&#34;, &#34;M&#34;, &#34;G&#34;], sep=&#34;!&#34;)
        &#39;O!M!G&#39;
        &gt;&gt;&gt; concat([&#34;sport&#34;], sep=&#34; &#34;, indexes=[0, 2])
        &#39;sport&#39;
        &gt;&gt;&gt; concat([&#34;sport&#34;, &#34;fr&#34;, &#34;collectif&#34;], sep=&#34; &#34;, indexes=[0, 2])
        &#39;sport collectif&#39;
        &gt;&gt;&gt; concat([&#34;marca&#34;, &#34;ca&#34;, &#34;antigament&#34;, &#34;_&#34;, &#34;en plural&#34;], sep=&#34; &#34;, indexes=[2, 3, 4, 5], skip=&#34;_&#34;)
        &#39;antigament en plural&#39;
        &gt;&gt;&gt; concat([&#34;antigament&#34;, &#34;_&#34;, &#34;en plural&#34;], sep=&#34;,&#34;, skip=&#34;_&#34;)
        &#39;antigament en plural&#39;
        &gt;&gt;&gt; concat([&#34;Arte&#34;, &#34;&#34;, &#34;&#34;], sep=&#34; e &#34;)
        &#39;Arte&#39;
    &#34;&#34;&#34;
    if indexes:
        result = [part for index, part in enumerate(parts) if index in indexes]
    else:
        result = list(parts)

    if skip:
        result = [part for part in result if part != skip]
        if parts.count(skip):
            sep = &#34; &#34;

    return sep.join(p for p in result if p)</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.coord"><code class="name flex">
<span>def <span class="ident">coord</span></span>(<span>values: Tuple[str, ...]) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format lon/lat coordinates.</p>
<pre><code>&gt;&gt;&gt; coord(["04", "39", "N", "74", "03", "O", "type:country"])
'04°39′N 74°03′O'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coord(values: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Format lon/lat coordinates.

        &gt;&gt;&gt; coord([&#34;04&#34;, &#34;39&#34;, &#34;N&#34;, &#34;74&#34;, &#34;03&#34;, &#34;O&#34;, &#34;type:country&#34;])
        &#39;04°39′N 74°03′O&#39;
    &#34;&#34;&#34;
    return &#34;{0}°{1}′{2} {3}°{4}′{5}&#34;.format(*values)</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.etymology"><code class="name flex">
<span>def <span class="ident">etymology</span></span>(<span>parts: Tuple[str, ...]) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Display cross-language etymology.</p>
<pre><code>&gt;&gt;&gt; etymology("étyl|grc|fr".split("|"))
'grec ancien'
&gt;&gt;&gt; etymology("étyl|no|fr|mot=ski".split("|"))
'norvégien &lt;i&gt;ski&lt;/i&gt;'
&gt;&gt;&gt; etymology("étyl|la|fr|mot=invito|type=verb".split("|"))
'latin &lt;i&gt;invito&lt;/i&gt;'
&gt;&gt;&gt; etymology("étyl|grc|fr|mot=λόγος|tr=lógos|type=nom|sens=étude".split("|"))
'grec ancien λόγος, &lt;i&gt;lógos&lt;/i&gt; (« étude »)'
&gt;&gt;&gt; etymology("étyl|grc|fr|λόγος|lógos|étude|type=nom|lien=1".split("|"))
'grec ancien λόγος, &lt;i&gt;lógos&lt;/i&gt; (« étude »)'
&gt;&gt;&gt; etymology("calque|la|fr".split("|"))
'latin'
&gt;&gt;&gt; etymology("calque|en|fr|mot=to date|sens=à ce jour".split("|"))
'anglais &lt;i&gt;to date&lt;/i&gt; (« à ce jour »)'
&gt;&gt;&gt; etymology("calque|sa|fr|mot=वज्रयान|tr=vajrayāna|sens=véhicule du diamant".split("|"))
'sanskrit वज्रयान, &lt;i&gt;vajrayāna&lt;/i&gt; (« véhicule du diamant »)'
</code></pre>
<p>Source: <a href="https://fr.wiktionary.org/wiki/Mod%C3%A8le:%C3%A9tyl">https://fr.wiktionary.org/wiki/Mod%C3%A8le:%C3%A9tyl</a></p>
<p>Source: <a href="https://fr.wiktionary.org/wiki/Mod%C3%A8le:calque">https://fr.wiktionary.org/wiki/Mod%C3%A8le:calque</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def etymology(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Display cross-language etymology.

        &gt;&gt;&gt; etymology(&#34;étyl|grc|fr&#34;.split(&#34;|&#34;))
        &#39;grec ancien&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|no|fr|mot=ski&#34;.split(&#34;|&#34;))
        &#39;norvégien &lt;i&gt;ski&lt;/i&gt;&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|la|fr|mot=invito|type=verb&#34;.split(&#34;|&#34;))
        &#39;latin &lt;i&gt;invito&lt;/i&gt;&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|grc|fr|mot=λόγος|tr=lógos|type=nom|sens=étude&#34;.split(&#34;|&#34;))
        &#39;grec ancien λόγος, &lt;i&gt;lógos&lt;/i&gt; (« étude »)&#39;
        &gt;&gt;&gt; etymology(&#34;étyl|grc|fr|λόγος|lógos|étude|type=nom|lien=1&#34;.split(&#34;|&#34;))
        &#39;grec ancien λόγος, &lt;i&gt;lógos&lt;/i&gt; (« étude »)&#39;
        &gt;&gt;&gt; etymology(&#34;calque|la|fr&#34;.split(&#34;|&#34;))
        &#39;latin&#39;
        &gt;&gt;&gt; etymology(&#34;calque|en|fr|mot=to date|sens=à ce jour&#34;.split(&#34;|&#34;))
        &#39;anglais &lt;i&gt;to date&lt;/i&gt; (« à ce jour »)&#39;
        &gt;&gt;&gt; etymology(&#34;calque|sa|fr|mot=वज्रयान|tr=vajrayāna|sens=véhicule du diamant&#34;.split(&#34;|&#34;))
        &#39;sanskrit वज्रयान, &lt;i&gt;vajrayāna&lt;/i&gt; (« véhicule du diamant »)&#39;

    Source: https://fr.wiktionary.org/wiki/Mod%C3%A8le:%C3%A9tyl

    Source: https://fr.wiktionary.org/wiki/Mod%C3%A8le:calque
    &#34;&#34;&#34;
    l10n_src = parts[1]
    l10n_dst = parts[2]
    res = all_langs[l10n_dst][l10n_src]
    if len(parts) == 3:
        return res

    data = {}
    for part in parts[3:]:
        if &#34;=&#34; in part:
            key, value = part.split(&#34;=&#34;)
            data[key] = value
        elif &#34;mot&#34; not in data:
            data[&#34;mot&#34;] = part
        elif &#34;tr&#34; not in data:
            data[&#34;tr&#34;] = part
        elif &#34;sens&#34; not in data:
            data[&#34;sens&#34;] = part

    if &#34;tr&#34; in data:
        res += f&#34; {data[&#39;mot&#39;]}, &lt;i&gt;{data[&#39;tr&#39;]}&lt;/i&gt;&#34;
    else:
        res += f&#34; &lt;i&gt;{data[&#39;mot&#39;]}&lt;/i&gt;&#34;
    if &#34;sens&#34; in data:
        res += f&#34; (« {data[&#39;sens&#39;]} »)&#34;

    return res</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.eval_expr"><code class="name flex">
<span>def <span class="ident">eval_expr</span></span>(<span>expr: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Compute and return the result of <em>expr</em>.</p>
<pre><code>&gt;&gt;&gt; eval_expr("2 ^ 30")
'1073741824'
</code></pre>
<p><em>expr</em> is sanitized and only a small range of characters are allowed:</p>
<pre><code>&gt;&gt;&gt; eval_expr("cat /etc/passwd")  # doctest: +ELLIPSIS
Traceback (most recent call last):
  File ".../doctest.py", line 1329, in __run
    compileflags, 1), test.globs)
  File "&lt;doctest scripts.user_functions.eval_expr[0]&gt;", line 1, in &lt;module&gt;
  File ".../user_functions.py", line 33, in eval_expr
    raise ValueError(f"Dangerous characters in the expr {expr!r}")
ValueError: Dangerous characters in the expr 'cat /etc/passwd'
</code></pre>
<p>Allowed characters are digits (0-9), spaces and operators (+-*^).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def eval_expr(expr: str) -&gt; str:
    &#34;&#34;&#34;
    Compute and return the result of *expr*.

        &gt;&gt;&gt; eval_expr(&#34;2 ^ 30&#34;)
        &#39;1073741824&#39;

    *expr* is sanitized and only a small range of characters are allowed:

        &gt;&gt;&gt; eval_expr(&#34;cat /etc/passwd&#34;)  # doctest: +ELLIPSIS
        Traceback (most recent call last):
          File &#34;.../doctest.py&#34;, line 1329, in __run
            compileflags, 1), test.globs)
          File &#34;&lt;doctest scripts.user_functions.eval_expr[0]&gt;&#34;, line 1, in &lt;module&gt;
          File &#34;.../user_functions.py&#34;, line 33, in eval_expr
            raise ValueError(f&#34;Dangerous characters in the expr {expr!r}&#34;)
        ValueError: Dangerous characters in the expr &#39;cat /etc/passwd&#39;

    Allowed characters are digits (0-9), spaces and operators (+-*^).
    &#34;&#34;&#34;
    # Prevent horrors
    # digits, space and operators (+-*^)
    if re.search(r&#34;[^\d\s\*\-\+\^\.]+&#34;, expr):
        raise ValueError(f&#34;Dangerous characters in the expr {expr!r}&#34;)

    # Replace signs
    expr = expr.replace(&#34;^&#34;, &#34;**&#34;)

    return f&#34;{eval(expr)}&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.int_to_roman"><code class="name flex">
<span>def <span class="ident">int_to_roman</span></span>(<span>number: int) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an integer to a Roman numeral.</p>
<pre><code>&gt;&gt;&gt; int_to_roman(12)
'XII'
&gt;&gt;&gt; int_to_roman(2020)
'MMXX'
</code></pre>
<p>Source: <a href="https://www.oreilly.com/library/view/python-cookbook/0596001673/ch03s24.html">https://www.oreilly.com/library/view/python-cookbook/0596001673/ch03s24.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def int_to_roman(number: int) -&gt; str:
    &#34;&#34;&#34;
    Convert an integer to a Roman numeral.

        &gt;&gt;&gt; int_to_roman(12)
        &#39;XII&#39;
        &gt;&gt;&gt; int_to_roman(2020)
        &#39;MMXX&#39;

    Source: https://www.oreilly.com/library/view/python-cookbook/0596001673/ch03s24.html
    &#34;&#34;&#34;
    # if not 0 &lt; number &lt; 4000:
    #     raise ValueError(&#34;Argument must be between 1 and 3999&#34;)
    ints = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)
    nums = (&#34;M&#34;, &#34;CM&#34;, &#34;D&#34;, &#34;CD&#34;, &#34;C&#34;, &#34;XC&#34;, &#34;L&#34;, &#34;XL&#34;, &#34;X&#34;, &#34;IX&#34;, &#34;V&#34;, &#34;IV&#34;, &#34;I&#34;)
    result = []
    for i in range(len(ints)):
        count = int(number / ints[i])
        result.append(nums[i] * count)
        number -= ints[i] * count
    return &#34;&#34;.join(result)</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.italic"><code class="name flex">
<span>def <span class="ident">italic</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <em>text</em> surrounded by italic HTML tags.</p>
<pre><code>&gt;&gt;&gt; italic("foo")
'&lt;i&gt;foo&lt;/i&gt;'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def italic(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by italic HTML tags.

        &gt;&gt;&gt; italic(&#34;foo&#34;)
        &#39;&lt;i&gt;foo&lt;/i&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;i&gt;{text}&lt;/i&gt;&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.lookup_italic"><code class="name flex">
<span>def <span class="ident">lookup_italic</span></span>(<span>word: str, locale: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Find the <em>word</em> from the <em>templates_italic</em> table of the given <em>locale</em>.</p>
<p>If the <em>word</em> is not found, it is returned as-is.</p>
<pre><code>&gt;&gt;&gt; lookup_italic("", "fr")
''
&gt;&gt;&gt; lookup_italic("absol", "fr")
'Absolument'
&gt;&gt;&gt; lookup_italic("inexistant", "fr")
'inexistant'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup_italic(word: str, locale: str) -&gt; str:
    &#34;&#34;&#34;
    Find the *word* from the *templates_italic* table of the given *locale*.

    If the *word* is not found, it is returned as-is.

        &gt;&gt;&gt; lookup_italic(&#34;&#34;, &#34;fr&#34;)
        &#39;&#39;
        &gt;&gt;&gt; lookup_italic(&#34;absol&#34;, &#34;fr&#34;)
        &#39;Absolument&#39;
        &gt;&gt;&gt; lookup_italic(&#34;inexistant&#34;, &#34;fr&#34;)
        &#39;inexistant&#39;
    &#34;&#34;&#34;
    return templates_italic[locale].get(word, word)</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.number"><code class="name flex">
<span>def <span class="ident">number</span></span>(<span>number: str, fsep: str, tsep: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format a number using the provided float and thousands separators.</p>
<pre><code>&gt;&gt;&gt; number("1 000 000 000 000", ",", " ")
'1 000 000 000 000'
&gt;&gt;&gt; number("1000000", ",", " ")
'1 000 000'
&gt;&gt;&gt; number("1000000", ".", "")
'1000000'
&gt;&gt;&gt; number("1000000", ".", ",")
'1,000,000'
&gt;&gt;&gt; number("-1000000", ",", " ")
'-1 000 000'
&gt;&gt;&gt; number("-1000000", "", "")
'-1000000'
&gt;&gt;&gt; number("-1000000", ".", ",")
'-1,000,000'
&gt;&gt;&gt; number("4.54609", "," , " ")
'4,54609'
&gt;&gt;&gt; number("4.54609", "." , ",")
'4.54609'
&gt;&gt;&gt; number("22905", "," , ".")
'22.905'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number(number: str, fsep: str, tsep: str) -&gt; str:
    &#34;&#34;&#34;
    Format a number using the provided float and thousands separators.

        &gt;&gt;&gt; number(&#34;1 000 000 000 000&#34;, &#34;,&#34;, &#34; &#34;)
        &#39;1 000 000 000 000&#39;
        &gt;&gt;&gt; number(&#34;1000000&#34;, &#34;,&#34;, &#34; &#34;)
        &#39;1 000 000&#39;
        &gt;&gt;&gt; number(&#34;1000000&#34;, &#34;.&#34;, &#34;&#34;)
        &#39;1000000&#39;
        &gt;&gt;&gt; number(&#34;1000000&#34;, &#34;.&#34;, &#34;,&#34;)
        &#39;1,000,000&#39;
        &gt;&gt;&gt; number(&#34;-1000000&#34;, &#34;,&#34;, &#34; &#34;)
        &#39;-1 000 000&#39;
        &gt;&gt;&gt; number(&#34;-1000000&#34;, &#34;&#34;, &#34;&#34;)
        &#39;-1000000&#39;
        &gt;&gt;&gt; number(&#34;-1000000&#34;, &#34;.&#34;, &#34;,&#34;)
        &#39;-1,000,000&#39;
        &gt;&gt;&gt; number(&#34;4.54609&#34;, &#34;,&#34; , &#34; &#34;)
        &#39;4,54609&#39;
        &gt;&gt;&gt; number(&#34;4.54609&#34;, &#34;.&#34; , &#34;,&#34;)
        &#39;4.54609&#39;
        &gt;&gt;&gt; number(&#34;22905&#34;, &#34;,&#34; , &#34;.&#34;)
        &#39;22.905&#39;
    &#34;&#34;&#34;
    # Remove superfluous spaces
    number = number.replace(&#34; &#34;, &#34;&#34;)

    try:
        # Integer
        res = f&#34;{int(number):,}&#34;
    except ValueError:
        # Float
        res = f&#34;{float(number):,}&#34;

    # Replace the current thousands separator with &#34;|&#34;;
    # then replace the dot with the float separator;
    # and lastly replace the &#34;|&#34; with the deisred thousands separator.
    # This 3-steps-replacement is needed for when separators are replacing each other.
    return res.replace(&#34;,&#34;, &#34;|&#34;).replace(&#34;.&#34;, fsep).replace(&#34;|&#34;, tsep)</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.person"><code class="name flex">
<span>def <span class="ident">person</span></span>(<span>parts: Tuple[str, ...]) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format a person name.</p>
<pre><code>&gt;&gt;&gt; person(["Aldous", "Huxley"])
"Aldous &lt;span style='font-variant:small-caps'&gt;Huxley&lt;/span&gt;"
&gt;&gt;&gt; person(["Théodore Agrippa d’", "Aubigné"])
"Théodore Agrippa d’ &lt;span style='font-variant:small-caps'&gt;Aubigné&lt;/span&gt;"
&gt;&gt;&gt; person(["Théodore Agrippa d’", "Aubigné", "'=oui"])
"Théodore Agrippa d’&lt;span style='font-variant:small-caps'&gt;Aubigné&lt;/span&gt;"
&gt;&gt;&gt; person(["L. L. Zamenhof"])
'L. L. Zamenhof'
</code></pre>
<p>Source: <a href="https://fr.wiktionary.org/wiki/Mod%C3%A8le:nom_w_pc">https://fr.wiktionary.org/wiki/Mod%C3%A8le:nom_w_pc</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def person(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Format a person name.

        &gt;&gt;&gt; person([&#34;Aldous&#34;, &#34;Huxley&#34;])
        &#34;Aldous &lt;span style=&#39;font-variant:small-caps&#39;&gt;Huxley&lt;/span&gt;&#34;
        &gt;&gt;&gt; person([&#34;Théodore Agrippa d’&#34;, &#34;Aubigné&#34;])
        &#34;Théodore Agrippa d’ &lt;span style=&#39;font-variant:small-caps&#39;&gt;Aubigné&lt;/span&gt;&#34;
        &gt;&gt;&gt; person([&#34;Théodore Agrippa d’&#34;, &#34;Aubigné&#34;, &#34;&#39;=oui&#34;])
        &#34;Théodore Agrippa d’&lt;span style=&#39;font-variant:small-caps&#39;&gt;Aubigné&lt;/span&gt;&#34;
        &gt;&gt;&gt; person([&#34;L. L. Zamenhof&#34;])
        &#39;L. L. Zamenhof&#39;

    Source: https://fr.wiktionary.org/wiki/Mod%C3%A8le:nom_w_pc
    &#34;&#34;&#34;
    res = parts[0]
    if len(parts) &gt; 1:
        if parts[-1] != &#34;&#39;=oui&#34;:
            res += &#34; &#34;
        res += small_caps(parts[1])
    else:
        warn(f&#34;Malformed template in the Wikicode (parts={parts})&#34;)
    return res</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.sentence"><code class="name flex">
<span>def <span class="ident">sentence</span></span>(<span>parts: Tuple[str, ...]) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Capitalize the first item in <em>parts</em> and concat with the second one.</p>
<pre><code>&gt;&gt;&gt; sentence("superlatif de|petit|fr".split("|"))
'Superlatif de petit'
&gt;&gt;&gt; sentence("variante de|ranche|fr".split("|"))
'Variante de ranche'
&gt;&gt;&gt; sentence("RFC|5322".split("|"))
'RFC 5322'
&gt;&gt;&gt; sentence("comparatif de|bien|fr|adv".split("|"))
'Comparatif de bien'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sentence(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Capitalize the first item in *parts* and concat with the second one.

        &gt;&gt;&gt; sentence(&#34;superlatif de|petit|fr&#34;.split(&#34;|&#34;))
        &#39;Superlatif de petit&#39;
        &gt;&gt;&gt; sentence(&#34;variante de|ranche|fr&#34;.split(&#34;|&#34;))
        &#39;Variante de ranche&#39;
        &gt;&gt;&gt; sentence(&#34;RFC|5322&#34;.split(&#34;|&#34;))
        &#39;RFC 5322&#39;
        &gt;&gt;&gt; sentence(&#34;comparatif de|bien|fr|adv&#34;.split(&#34;|&#34;))
        &#39;Comparatif de bien&#39;
    &#34;&#34;&#34;
    return capitalize(concat(parts, sep=&#34; &#34;, indexes=[0, 1]))</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.small"><code class="name flex">
<span>def <span class="ident">small</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <em>text</em> surrounded by small HTML tags.</p>
<pre><code>&gt;&gt;&gt; small("foo")
'&lt;small&gt;foo&lt;/small&gt;'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def small(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by small HTML tags.

        &gt;&gt;&gt; small(&#34;foo&#34;)
        &#39;&lt;small&gt;foo&lt;/small&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;small&gt;{text}&lt;/small&gt;&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.small_caps"><code class="name flex">
<span>def <span class="ident">small_caps</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <em>text</em> surrounded by the CSS style to use small capitals.</p>
<p>Small-caps glyphs typically use the form of uppercase letters but are reduced
to the size of lowercase letters.</p>
<pre><code>&gt;&gt;&gt; small_caps("Dupont")
"&lt;span style='font-variant:small-caps'&gt;Dupont&lt;/span&gt;"
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def small_caps(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by the CSS style to use small capitals.

    Small-caps glyphs typically use the form of uppercase letters but are reduced
    to the size of lowercase letters.

        &gt;&gt;&gt; small_caps(&#34;Dupont&#34;)
        &#34;&lt;span style=&#39;font-variant:small-caps&#39;&gt;Dupont&lt;/span&gt;&#34;
    &#34;&#34;&#34;
    return f&#34;&lt;span style=&#39;font-variant:small-caps&#39;&gt;{text}&lt;/span&gt;&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.strong"><code class="name flex">
<span>def <span class="ident">strong</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <em>text</em> surrounded by strong HTML tags.</p>
<pre><code>&gt;&gt;&gt; strong("foo")
'&lt;b&gt;foo&lt;/b&gt;'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strong(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by strong HTML tags.

        &gt;&gt;&gt; strong(&#34;foo&#34;)
        &#39;&lt;b&gt;foo&lt;/b&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;b&gt;{text}&lt;/b&gt;&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.subscript"><code class="name flex">
<span>def <span class="ident">subscript</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <em>text</em> surrounded by subscript HTML tags.</p>
<p>Subscript text appears half a character below the normal line,
and is sometimes rendered in a smaller font.
Subscript text can be used for chemical formulas.</p>
<pre><code>&gt;&gt;&gt; subscript("foo")
'&lt;sub&gt;foo&lt;/sub&gt;'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscript(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by subscript HTML tags.

    Subscript text appears half a character below the normal line,
    and is sometimes rendered in a smaller font.
    Subscript text can be used for chemical formulas.

        &gt;&gt;&gt; subscript(&#34;foo&#34;)
        &#39;&lt;sub&gt;foo&lt;/sub&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;sub&gt;{text}&lt;/sub&gt;&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.superscript"><code class="name flex">
<span>def <span class="ident">superscript</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the <em>text</em> surrounded by superscript HTML tags.</p>
<p>Superscript text appears half a character above the normal line,
and is sometimes rendered in a smaller font.</p>
<pre><code>&gt;&gt;&gt; superscript("foo")
'&lt;sup&gt;foo&lt;/sup&gt;'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def superscript(text: str) -&gt; str:
    &#34;&#34;&#34;
    Return the *text* surrounded by superscript HTML tags.

    Superscript text appears half a character above the normal line,
    and is sometimes rendered in a smaller font.

        &gt;&gt;&gt; superscript(&#34;foo&#34;)
        &#39;&lt;sup&gt;foo&lt;/sup&gt;&#39;
    &#34;&#34;&#34;
    return f&#34;&lt;sup&gt;{text}&lt;/sup&gt;&#34;</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.tag"><code class="name flex">
<span>def <span class="ident">tag</span></span>(<span>parts: Tuple[str, ...]) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Get only interesting values from <em>parts</em>.</p>
<ul>
<li>values without <code>=</code></li>
<li>values starting with <code>text=</code></li>
</ul>
<p>Source: <a href="https://sv.wiktionary.org/wiki/Mall:tagg">https://sv.wiktionary.org/wiki/Mall:tagg</a></p>
<pre><code>&gt;&gt;&gt; tag(["historia"])
'historia'
&gt;&gt;&gt; tag(["biologi", "allmänt"])
'biologi, allmänt'
&gt;&gt;&gt; tag("politik|formellt|språk=tyska".split("|"))
'politik, formellt'
&gt;&gt;&gt; tag("kat=nedsättande|text=något nedsättande".split("|"))
'något nedsättande'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tag(parts: Tuple[str, ...]) -&gt; str:
    &#34;&#34;&#34;
    Get only interesting values from *parts*.

    - values without `=`
    - values starting with `text=`

    Source: https://sv.wiktionary.org/wiki/Mall:tagg

        &gt;&gt;&gt; tag([&#34;historia&#34;])
        &#39;historia&#39;
        &gt;&gt;&gt; tag([&#34;biologi&#34;, &#34;allmänt&#34;])
        &#39;biologi, allmänt&#39;
        &gt;&gt;&gt; tag(&#34;politik|formellt|språk=tyska&#34;.split(&#34;|&#34;))
        &#39;politik, formellt&#39;
        &gt;&gt;&gt; tag(&#34;kat=nedsättande|text=något nedsättande&#34;.split(&#34;|&#34;))
        &#39;något nedsättande&#39;
    &#34;&#34;&#34;
    words = []

    for part in parts:
        if &#34;=&#34; not in part:
            words.append(part)
        elif part.startswith(&#34;text=&#34;):
            words.append(part.split(&#34;=&#34;)[1])

    return &#34;, &#34;.join(words)</code></pre>
</details>
</dd>
<dt id="scripts.user_functions.term"><code class="name flex">
<span>def <span class="ident">term</span></span>(<span>text: str) -> str</span>
</code></dt>
<dd>
<div class="desc"><p>Format a "term", e.g. return the <em>text</em> in italic and surrounded by parenthesis.</p>
<p>If the <em>text</em> is already in such style, it will not be processed again.</p>
<pre><code>&gt;&gt;&gt; term("")
''
&gt;&gt;&gt; term("foo")
'&lt;i&gt;(foo)&lt;/i&gt;'
&gt;&gt;&gt; term("Foo")
'&lt;i&gt;(Foo)&lt;/i&gt;'
&gt;&gt;&gt; term("&lt;i&gt;(Foo)&lt;/i&gt;")
'&lt;i&gt;(Foo)&lt;/i&gt;'
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def term(text: str) -&gt; str:
    &#34;&#34;&#34;
    Format a &#34;term&#34;, e.g. return the *text* in italic and surrounded by parenthesis.

    If the *text* is already in such style, it will not be processed again.

        &gt;&gt;&gt; term(&#34;&#34;)
        &#39;&#39;
        &gt;&gt;&gt; term(&#34;foo&#34;)
        &#39;&lt;i&gt;(foo)&lt;/i&gt;&#39;
        &gt;&gt;&gt; term(&#34;Foo&#34;)
        &#39;&lt;i&gt;(Foo)&lt;/i&gt;&#39;
        &gt;&gt;&gt; term(&#34;&lt;i&gt;(Foo)&lt;/i&gt;&#34;)
        &#39;&lt;i&gt;(Foo)&lt;/i&gt;&#39;
    &#34;&#34;&#34;
    if not text:
        return &#34;&#34;
    elif text.startswith(&#34;&lt;i&gt;(&#34;):
        return text
    return italic(f&#34;({text})&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="scripts.user_functions.capitalize" href="#scripts.user_functions.capitalize">capitalize</a></code></li>
<li><code><a title="scripts.user_functions.century" href="#scripts.user_functions.century">century</a></code></li>
<li><code><a title="scripts.user_functions.chimy" href="#scripts.user_functions.chimy">chimy</a></code></li>
<li><code><a title="scripts.user_functions.color" href="#scripts.user_functions.color">color</a></code></li>
<li><code><a title="scripts.user_functions.concat" href="#scripts.user_functions.concat">concat</a></code></li>
<li><code><a title="scripts.user_functions.coord" href="#scripts.user_functions.coord">coord</a></code></li>
<li><code><a title="scripts.user_functions.etymology" href="#scripts.user_functions.etymology">etymology</a></code></li>
<li><code><a title="scripts.user_functions.eval_expr" href="#scripts.user_functions.eval_expr">eval_expr</a></code></li>
<li><code><a title="scripts.user_functions.int_to_roman" href="#scripts.user_functions.int_to_roman">int_to_roman</a></code></li>
<li><code><a title="scripts.user_functions.italic" href="#scripts.user_functions.italic">italic</a></code></li>
<li><code><a title="scripts.user_functions.lookup_italic" href="#scripts.user_functions.lookup_italic">lookup_italic</a></code></li>
<li><code><a title="scripts.user_functions.number" href="#scripts.user_functions.number">number</a></code></li>
<li><code><a title="scripts.user_functions.person" href="#scripts.user_functions.person">person</a></code></li>
<li><code><a title="scripts.user_functions.sentence" href="#scripts.user_functions.sentence">sentence</a></code></li>
<li><code><a title="scripts.user_functions.small" href="#scripts.user_functions.small">small</a></code></li>
<li><code><a title="scripts.user_functions.small_caps" href="#scripts.user_functions.small_caps">small_caps</a></code></li>
<li><code><a title="scripts.user_functions.strong" href="#scripts.user_functions.strong">strong</a></code></li>
<li><code><a title="scripts.user_functions.subscript" href="#scripts.user_functions.subscript">subscript</a></code></li>
<li><code><a title="scripts.user_functions.superscript" href="#scripts.user_functions.superscript">superscript</a></code></li>
<li><code><a title="scripts.user_functions.tag" href="#scripts.user_functions.tag">tag</a></code></li>
<li><code><a title="scripts.user_functions.term" href="#scripts.user_functions.term">term</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>